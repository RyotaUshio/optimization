# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_continuous')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_continuous')
    _continuous = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_continuous', [dirname(__file__)])
        except ImportError:
            import _continuous
            return _continuous
        try:
            _mod = imp.load_module('_continuous', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _continuous = swig_import_helper()
    del swig_import_helper
else:
    import _continuous
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class objFunc(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, objFunc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, objFunc, name)
    __repr__ = _swig_repr
    __swig_getmethods__["func"] = _continuous.objFunc_func_get
    if _newclass:
        func = _swig_property(_continuous.objFunc_func_get)
    __swig_getmethods__["grad"] = _continuous.objFunc_grad_get
    if _newclass:
        grad = _swig_property(_continuous.objFunc_grad_get)
    __swig_getmethods__["hesse"] = _continuous.objFunc_hesse_get
    if _newclass:
        hesse = _swig_property(_continuous.objFunc_hesse_get)

    def __init__(self, *args):
        this = _continuous.new_objFunc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, x):
        return _continuous.objFunc___call__(self, x)
    __swig_destroy__ = _continuous.delete_objFunc
    __del__ = lambda self: None
objFunc_swigregister = _continuous.objFunc_swigregister
objFunc_swigregister(objFunc)

class constraint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, constraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, constraint, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _continuous.new_constraint()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _continuous.delete_constraint
    __del__ = lambda self: None
constraint_swigregister = _continuous.constraint_swigregister
constraint_swigregister(constraint)

class eqConstraint(constraint):
    __swig_setmethods__ = {}
    for _s in [constraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, eqConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, eqConstraint, name)
    __repr__ = _swig_repr
    __swig_setmethods__["g"] = _continuous.eqConstraint_g_set
    __swig_getmethods__["g"] = _continuous.eqConstraint_g_get
    if _newclass:
        g = _swig_property(_continuous.eqConstraint_g_get, _continuous.eqConstraint_g_set)

    def __init__(self):
        this = _continuous.new_eqConstraint()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _continuous.delete_eqConstraint
    __del__ = lambda self: None
eqConstraint_swigregister = _continuous.eqConstraint_swigregister
eqConstraint_swigregister(eqConstraint)

class ineqConstraint(eqConstraint):
    __swig_setmethods__ = {}
    for _s in [eqConstraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ineqConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [eqConstraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ineqConstraint, name)
    __repr__ = _swig_repr
    __swig_setmethods__["h"] = _continuous.ineqConstraint_h_set
    __swig_getmethods__["h"] = _continuous.ineqConstraint_h_get
    if _newclass:
        h = _swig_property(_continuous.ineqConstraint_h_get, _continuous.ineqConstraint_h_set)

    def __init__(self):
        this = _continuous.new_ineqConstraint()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _continuous.delete_ineqConstraint
    __del__ = lambda self: None
ineqConstraint_swigregister = _continuous.ineqConstraint_swigregister
ineqConstraint_swigregister(ineqConstraint)

class problem(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, problem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, problem, name)
    __repr__ = _swig_repr
    __swig_getmethods__["f"] = _continuous.problem_f_get
    if _newclass:
        f = _swig_property(_continuous.problem_f_get)
    __swig_setmethods__["c"] = _continuous.problem_c_set
    __swig_getmethods__["c"] = _continuous.problem_c_get
    if _newclass:
        c = _swig_property(_continuous.problem_c_get, _continuous.problem_c_set)

    def __init__(self, *args):
        this = _continuous.new_problem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _continuous.delete_problem
    __del__ = lambda self: None
problem_swigregister = _continuous.problem_swigregister
problem_swigregister(problem)

class iterativeSolver(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, iterativeSolver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, iterativeSolver, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _continuous.iterativeSolver_eps_set
    __swig_getmethods__["eps"] = _continuous.iterativeSolver_eps_get
    if _newclass:
        eps = _swig_property(_continuous.iterativeSolver_eps_get, _continuous.iterativeSolver_eps_set)

    def converge(self, prob, x):
        return _continuous.iterativeSolver_converge(self, prob, x)

    def __call__(self, prob, x0):
        return _continuous.iterativeSolver___call__(self, prob, x0)

    def update(self, prob, x):
        return _continuous.iterativeSolver_update(self, prob, x)
    __swig_destroy__ = _continuous.delete_iterativeSolver
    __del__ = lambda self: None
iterativeSolver_swigregister = _continuous.iterativeSolver_swigregister
iterativeSolver_swigregister(iterativeSolver)

class lineSearchSolver(iterativeSolver):
    __swig_setmethods__ = {}
    for _s in [iterativeSolver]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, lineSearchSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [iterativeSolver]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, lineSearchSolver, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_setmethods__["use_wolfe"] = _continuous.lineSearchSolver_use_wolfe_set
    __swig_getmethods__["use_wolfe"] = _continuous.lineSearchSolver_use_wolfe_get
    if _newclass:
        use_wolfe = _swig_property(_continuous.lineSearchSolver_use_wolfe_get, _continuous.lineSearchSolver_use_wolfe_set)
    __swig_setmethods__["c1"] = _continuous.lineSearchSolver_c1_set
    __swig_getmethods__["c1"] = _continuous.lineSearchSolver_c1_get
    if _newclass:
        c1 = _swig_property(_continuous.lineSearchSolver_c1_get, _continuous.lineSearchSolver_c1_set)
    __swig_setmethods__["c2"] = _continuous.lineSearchSolver_c2_set
    __swig_getmethods__["c2"] = _continuous.lineSearchSolver_c2_get
    if _newclass:
        c2 = _swig_property(_continuous.lineSearchSolver_c2_get, _continuous.lineSearchSolver_c2_set)
    __swig_setmethods__["rho"] = _continuous.lineSearchSolver_rho_set
    __swig_getmethods__["rho"] = _continuous.lineSearchSolver_rho_get
    if _newclass:
        rho = _swig_property(_continuous.lineSearchSolver_rho_get, _continuous.lineSearchSolver_rho_set)
    __swig_setmethods__["alpha0"] = _continuous.lineSearchSolver_alpha0_set
    __swig_getmethods__["alpha0"] = _continuous.lineSearchSolver_alpha0_get
    if _newclass:
        alpha0 = _swig_property(_continuous.lineSearchSolver_alpha0_get, _continuous.lineSearchSolver_alpha0_set)

    def dir(self, prob, x):
        return _continuous.lineSearchSolver_dir(self, prob, x)

    def alpha(self, prob, x, d):
        return _continuous.lineSearchSolver_alpha(self, prob, x, d)

    def Armijo(self, prob, x, a, d):
        return _continuous.lineSearchSolver_Armijo(self, prob, x, a, d)

    def curvature_condition(self, prob, x, a, d):
        return _continuous.lineSearchSolver_curvature_condition(self, prob, x, a, d)

    def alpha_armijo(self, prob, x, d):
        return _continuous.lineSearchSolver_alpha_armijo(self, prob, x, d)

    def alpha_wolfe(self, prob, x, d):
        return _continuous.lineSearchSolver_alpha_wolfe(self, prob, x, d)

    def update(self, prob, x):
        return _continuous.lineSearchSolver_update(self, prob, x)
    __swig_destroy__ = _continuous.delete_lineSearchSolver
    __del__ = lambda self: None
lineSearchSolver_swigregister = _continuous.lineSearchSolver_swigregister
lineSearchSolver_swigregister(lineSearchSolver)

class gradientDescent(lineSearchSolver):
    __swig_setmethods__ = {}
    for _s in [lineSearchSolver]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, gradientDescent, name, value)
    __swig_getmethods__ = {}
    for _s in [lineSearchSolver]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, gradientDescent, name)
    __repr__ = _swig_repr

    def __init__(self, wolfe=False):
        this = _continuous.new_gradientDescent(wolfe)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def dir(self, prob, x):
        return _continuous.gradientDescent_dir(self, prob, x)
    __swig_destroy__ = _continuous.delete_gradientDescent
    __del__ = lambda self: None
gradientDescent_swigregister = _continuous.gradientDescent_swigregister
gradientDescent_swigregister(gradientDescent)

class NewtonsMethod(lineSearchSolver):
    __swig_setmethods__ = {}
    for _s in [lineSearchSolver]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NewtonsMethod, name, value)
    __swig_getmethods__ = {}
    for _s in [lineSearchSolver]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NewtonsMethod, name)
    __repr__ = _swig_repr
    __swig_setmethods__["use_line_search"] = _continuous.NewtonsMethod_use_line_search_set
    __swig_getmethods__["use_line_search"] = _continuous.NewtonsMethod_use_line_search_get
    if _newclass:
        use_line_search = _swig_property(_continuous.NewtonsMethod_use_line_search_get, _continuous.NewtonsMethod_use_line_search_set)

    def __init__(self, line_search=False, wolfe=False):
        this = _continuous.new_NewtonsMethod(line_search, wolfe)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def dir(self, prob, x):
        return _continuous.NewtonsMethod_dir(self, prob, x)

    def alpha(self, prob, x, d):
        return _continuous.NewtonsMethod_alpha(self, prob, x, d)
    __swig_destroy__ = _continuous.delete_NewtonsMethod
    __del__ = lambda self: None
NewtonsMethod_swigregister = _continuous.NewtonsMethod_swigregister
NewtonsMethod_swigregister(NewtonsMethod)

# This file is compatible with both classic and new-style classes.


